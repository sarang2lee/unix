제11장 셸 스트립트 (Shell Script)

셸은 명령어 해석기이자 스크립트 언어이다. 셸 스크립트는 셸에 의해 수행되도록 작성된 프로그램으로 제어 구조에 따라  명령어나 함수를 실행한다. 


	11.1 셸 스크립트의 개요

00.
셸 스크립트는 평문의 텍스트 파일로 셸 명령어의 집합이라 할 수 있으며, 그 자체가 하나의 명령어처럼 실행될 수 있는 실행 가능한 프로그램이다. 물론 명령어 외에 함수나 변수의 선언, 파이프, 입출력 리다이렉션 등과 같이 셸에서 사용할 수 있는 모든 기능을 셸 스크립트에 포함하여 작성할 수 있다. 일반적 제어구조인 if 문, case 문, for 문, while 문 등을 사용하여 셸 스크립트를 작성할 수 있으며, 명령어 해석기라 할 수 있는 셸이 스크립트 퍄일의 내용을 읽어서 처리하게 된다.

리눅스 시스템을 부팅할 때 초기화 작업이 필요한 여러 명령을 실행하기 위하여 이러한 셸 스크립트를 사용한다. 이렇게 정기적으로 수행하는 작업, 특별한 시점에 수행하는 작업 또는 시스템 관리를 위해 수행되는 다수의 작업을 셸 스크립트로 만들어 둔다면 작업이 단순해지고 효과적일 것다.

  	1. 셸 스크립트의 실행 - bash Shell을 기준으로

1) bash 명령을 사용하고, 스크립트 파일의 이름을 인수로 사용하여 	bash file	과 같이 사용한다. 이때 스크립트 파일의 실행권한을 가질 필요는 없다.  
### 스크립트 파일은 .sh라는 확장자를 자주 사용한다.

2) 스크립트 파일의 이름 명령어로 사용한다. 단, 스크립트 파일의 접근권한 중에서 '실행권한'을 가지고 있어야 가능하다. 이 경우 스크립트 파일의 내용을 해석할 셸을 지정하기 위해 스크립트 파일의 첫 행을 #!	로 시작하고 이어서 셸의 정확한 이름을 쓴다. 첫 행이 #!/bin/bash인 경우 명령의 해석을 bash가 수행한다는 의미이다. #!를 'shebang'이라고 한다.

3) source file	을 실행한다. soruce 명령은 셸의 내장 명령로 현재 사용 중인 셸 환경 안에서 스크립트 파일을 실행하는 명령이다. source 명령 대신에 도트(.) 를 사용하여 . myScript 또는 . myScript.sh와 같이 실행할 수도 있다.
이 방법의 특징은 셸 스크립트를 현재 셸 환경에서 실행시키므로 셸 스크립트에서 변숫값 변경시킬 때, 그 변수의 값이 셸에서 계속 유효하다는 점이다. 이 방법은 서브셸을 만들어 실행시키므로 원래의 셸 환경에 영향을 미치지 못한다.

어느 방법을 사용하든 스크립트 실행 명령에서 스크립트 파일의 이름 다음에 인수를 추가로 사용할 수 있다. 
셸 스크립트를 작성할 때 $0는 스크립트 파일 이름, $1은 첫 번째 인수를 의미한다.

셸 스크립 파일에서 수행되는 명령이 매우 많거나 로직이 복잡하여 실행 시간이 오래 걸린다면, 실행 상황의 추적이 가능하고 오류 발생 위치 쉽게 찾을  있도록 echo 명령을 추가하는 것이 좋다. 또한 -x 옵션을 사용하여 bash -x file과 같이 실행하면 각 명령이 실행되기 전에 화면에 표시되어 수행되는 명령을 확인할 수 있다.


	11.2 변수의 사용

00.
변수의 사용이란 변수에 값을 저장하거나 변수에 저장된 값을 읽어오는 것이다. 셸 스크립트에서는 변수를 선언하지 않고 단순히 변수를 사용하기만 하면 된다. 즉, 존재하지 않는 변수를 사용하려 한다면 자동으로 변수를 만들고, 기본값은 빈 문자열로 주어지는 것이다. 


	1. 셸 변수

00. 셸 변수의 이름을 작명할 때 지켜야 하는 규칙은 다음과 같다.
	
	1) 대소문자를 구별한다. 그리고 일반적 변수의 경우 변수이름은 소문자로, 상수의 의미를 가질 때는 모두 대문자로 작명하는 관례가 있다.
	2) 영문자, 숫자, 언더스코어(_) 문자로 구성한다. 공백이나 구두점 기호를 사용할 수 없다.
	3) 숫자는 변수 이름의 첫 번째 문자가 될 수 없다.

01. 변수에 값을 지정하려면 셸 프롬프트에서 	변수이름=값	을 실행한다. 이때 등호의 좌우에 공백이 있어는 안된다. 데이터 유형은 문자열이다.
	
	1) 공백을 가진 문자열은 인용부호로 묶어 대입한다	b="A string"
	2) '변수 확장'이 우선이다. 즉 c="A string and $b"	는 $b를 변수확장 한 후 문자열을 변수 c 대입한다. 
								즉 결과는 c="A string and A sring"과 같다.
	3) d=$(ls | wc -1)	$(....)는 '명령 치환'을 의미한다. 즉 괄호 안의 명령을 실행한 후 결과를 변수 b에 대입한다.
	4) e=$[5*7]		$[....]는 '수식 확장'을 의미한다. 즉 대괄호 안의 수식을 계산한 후 결과를 변수 e에 대입한다. 즉 e=35와 같다.

	### 변수 값은 	echo $변수명	으로 확인 수 있다. 하지만 표준 출력은 	printf "$변수명"	이다.
	    		echo $변수명 명령에서 escape(\)를 인식시키려면 echo -e $변수명을 사용한다. 하지만 이는 표준이 아니다.
					### -e 옵션은 “enable interpretation of backslash escapes”의 약자입니다

	5) f="/t/t/A string\n"	이스케이프문자인 백슬래시(\)를 사용한 예이다. 문자 앞에 두 번의 탭(\t) 문자를, 
				문자열 뒤에 개행문자(\n)를 포함시킨다,
	6) g=5 h="A string\n"	한 행에 2개의 변수를 지정한 예이다.
	7) i=${b}1		변수 이름을 중괄호로 묶으면 뒤에 나오는 문자열을 분리할 수 있다. ="A string1"
	8) $a			이것을 수행하면 먼저 변수 확장이 일어나(즉 a=ls가 먼저 실행되어) 셸은 이것을 하나의 명령어로 해석하여 처리한다.
				즉, ls 명령이 실행된다.
	9) $a = $e		변수 확장이 먼저 일어나($a -->ls, $e = 35) 결과적으로 ls=35가 실행되어 ls 변수에 35가 대입된다.


	2. 명령 행 인수와 특수 매개변수
	
00.
셸이 사용하는 특별한 변수로 위치 매개변수(positional parameter)라는 것이 있다. 이것은 명령 행 인수(command line argument)로 사용되는 변수를 말하며, $1, $2, $3를 말한다. $1, $2, $3은 명령 행에서 사용된 첫 번째, 두 번째, 세 번째 인수를 의미한다. 한편, $0는 명령 행에서 사용된 스크립트 파일의 이름을 의미한다.

01.셸에서 사용되는 특수 매개변수
	1) $*	: 모든 위치 매개변수($0은 제외)를 포함하는 1개의 큰 따옴표, 즉 1개의 문자열로 "$1c$2c$3c..."로 확장된다. 
		  c는 내부필드구분자로 기본값은 공백문자이다.
	2) $@	: 위와 유사하나 "$@"는 열 개의 개별 큰따옴표, 즉 분리된 문자열로 확장된다. 즉, "$1" "$2" "$3"...과 같다.
	3) $$	: 셸의 프로세스 ID(PID)로 확장된다.
	4) $#	: 위치 매개변수의 개수로 확장된다.
	5) $?	: 최근에 실행된 포어그라운드 명령의 종료 상탯값으로 확장된다. 성공적으로 종료된 경우 0이다.
	6) $!	: 최근에 실행 백그라운드 명령의 프로세스 ID로 확장된다. 

	⚙️ 3. $* 와 $@ 의 차이
	
	✅ "$*" : 모든 인자를 하나의 문자열로 합침	print_params "$*"

		→ $*는 "first second third"로 전달됨.	함수 내부에서는 이것이 $1 한 개짜리 인자로 인식됩니다. 
							즉, 모든 인자가 합쳐져서 하나의 인자로 들어간 것입니다.
		출력:	"$*":
			$1 = first second third
			$2 =
			$3 =

	✅ "$@" : 인자들을 개별적으로 유지	print_params "$@"

		→ $@는 "first" 와 "second third" 두 개로 전달됨. 즉, $@는 각 인자를 따로따로 보존합니다.  

		출력:	"$@":
			$1 = first
			$2 = second third
			$3 =


	3. read 명령

00.
변수의 값 키보드로부터 입력받고자 할 때, 셸의 내장 명령인 read 명령을 사용할 수 있다.

		read [options] [variable...]

read 명령은 표준 입력으로부터 한 라인을 읽고 그 것을 단어들로 분할한 후 개별 단어를 상응하는 변수에 지정한다. read 명령에 변수 이름을 사용하지 않는다면 한 라인의 입력 전체가 셸 변수 REPLY에 저장된다.

	read -p "Type your first name, last name, and address: " first last address
 

	11.3 함수의 사용

00.
함수 정의가 셸 환경에 추가된다면 함수 이름을 셸 명령어처럼 사용할 수도 있다. 이를 위해서는 함수 정의를 가진 셸 스크립트를 source 명령이나 도트(.)를 사용하여 먼저 실행해 두어야 하는데, 셸 스크립트가 현재 셸 환경에서 자주 실되어 함수 정의가 현재 셸 환경에 포함되기 때문이다. 따라서 자주 사용되는 함수 정의는 	~/.bashrc 	파일에 포함시켜 두는 것이 좋다. 셸이 시작할 때 항상 실행되기 때문이다.

01. 함수 정의

	function name {
		command...
		return
	}

 name은 함수 이름이며, 중괄호 블럭 안에 명령을 작성한다. 명령은 셸 스크립트에 포함시킬 수 있는 것이라면 어떤 것이라도 가능하다. return 문은 함수 실행을 종료하는 문장이며 생략이 가능하다, 단, 함수는 최소 1개의 문장을 포함해야 한다. 다음과 같은 형식으로도 사용할 수 있다.

	name () {
		command ...
		return
	}
함수 정의를 무효화하려면 unset 함수명	을 실행하면 된다.

01.
스크립트 파일 whoson.sh에 실행권한을 부여한 후 쇼리행하는 것은 그것의 실행을 요청한 셸의 서브 셸에서만 유효하다. 따라서 원래의 셸에서는 함수와 변수가 정의되어 있지 않다. 따라서 함수를 다시 정의하지 않고 항상 사용하게 하려면, 메인 셸에서도 사용하려면, 터미널 창을 띄울 때 항상 실행되는 .bashrc 파일에 함수 정의를 추가하는 것이 좋다. 항상 사용하고 싶은 에일리어스 설정도 마찬가지이다.


	11.4 선택 구조

00.
셸 스크립트의 강력한 기능 중 하나는 프로그래밍 언어에서 사용되는 조건문이나 반복문을 제공한다는 점이다. 

	1. if 명령

00. if문의 기본 문법은 다음과 같다.

	if command...; 	then
		command...
	[elif command ,,,;	then
		command...] ...
	[else
		command...]
	fi

00. 설명
	1) 대괄호 부분은 생략 가능하다.
	2) 'command...'는 일련의 명령어를 의미한다. 
	   명령어 뒤의 세미콜론(;)은 같은 라인에서 명령어 다음에 나올 수 있는 다른 단어(then, elif, else, if 등) 구분이 필요할 때 꼭 사용해야 한다. 
	3) 명령어를 실행하면 그것이 종료될 때 상탯값(exit status)을 리턴한다. 셸 스크립트나 셸 함수를 실행시킬 때도 마찬가지이다. 
	   종료 시 상탯값은 0~255 사이의 정숫값으로 0은 성공적 종료를, 0이 아닌 경우는 '오류 발생'을 의미한다.
	4) if 다음에 나오는 명령어가 성공적으로 종료(종료 상탰값이 0)되면 then 다음의 명령을 수행하고 실행을 마친다. 
	   성공적으로 종료되지 않으면(종료 상탯값이 0이 아니면) elif 다음의 명령을 수행하는데, 역시 종료 상탯값으로 참 또는 거짓을 판단한다.
	5) 직전 명령의 상탯삾을 확인하기 위하여 echo $?를 실행할 수 있다.
	6) 셸 내장 명령 중 true 명령은 항상 성공적으로 종료되며, false 명령은 항상 실패한다. 

01.
	1) if문에서 조건 검사를 위해 자주 사용되는 명령으로 test 명령이 있다. test 명령을 사용하면 다양한 검사나 비교를 수행할 수 있으며, 
	   사용법은 	test expression	이다. test 명령은 수식의 결과에 따라 참 의미하는 0 또는 거짓을 의미하는 1을 리턴한다.
	2) test expression과 마찬가지로 [ expression ]	을 사용할 수 있는데, 좀 더 자주 사용되는 형식이다. 
	   대괄호 []와 expression 사이에 공백이 있어야 한다.

02. test 명령에서 파일의 상태 검사와 문자열 비교 수식에 사용되는 단어
	- test file1 -nt file2	: file1이 file2보다 새로운 것인가?
	- test file1 -ot file2	: file1이 file2보다 오래된 것인가?

	- test -d file	: 파일이 디렉터리인가?
	- test -e file	: 파일이 존재하는가?
	- test -f file	: 파일이 존재하고 정규파일(파일이 디렉터리나 링크 파일이 아닌 것)인가?
	- test -s file	: 파일이 존재하고 크기가 0보다 큰가?

	- test -r file	: 파일이 읽기 가능한가? 	'r'wx
	- test -x file	: 파일이 실행 가능한가?		rw'x'
	- test -w file	: 파일이 쓰기 가능한가? 	r'w'x

	- test -n string	: 문자열의 길이가 0보다 큰가?
	- test -z string	: 문자열의 길이가 0인가?
	- string1 \> string2	: 문자열1이 문자열2보다 큰가(사전순서)?
	- string \< string2	: 문자열1이 문자열2보다 작은가(사전순서)?

	- string1 = string2	: 문자열1이 문자열2와 같은가?  string1 == string2	와 동일하다. 
	- string1 != string2	: 문자열1이 문자열2와 다른가? 

03. 수식 합성에 사용되는 논리 연산자
	- !expr		: 수식이 거짓인가(not을 의미)
	- expr1 && expr2	: 두 수식이 모두 참인가(and를 의미)
	- expr1 || expr2	: 1개 이상의 수식이 참인가( or를 의미)

04. test 명령에서 정수 비교에 사용되는 연산자.
	- integer1 -eq integer2	: 정수1과 정수2가 같은가?(equal)
	- integer1 -ne integer2	: 정수1과 정수2가 다른가?(not equal)

	- integer1 -le integer2	: 정수1이 정수2보다 작거나 같은가(less or equal)
	- integer1 -lt integer2	: 정수1이 정수2보다 작은가 (less than)

	- integer1 -ge integer2	: 정수1이 정수 2보다 크거나 같은가? (greater or equal)
	- integer1 -gt integer2	: 정수1이 정수2보다 큰가? (greater than)


	2. case 명령

00.
case는 선택 제어 구조의 하나로 다중 선택을 지원하는 복합 명령이다. C언어나 Java 언어의 switch문과 의미가 같다.

	case word in
		[pattern [| pattern]...) command...;;]...
	esac
01.
	- case문은 word 부문을 먼저 확장한다. 그리고 이것을 pattern 부분과 패턴 매칭이 되는지 순서대로 검사한다.
	- 일치하는 것이 발견되면 더 이상 패턴을 검사하지 않고 종료한다. 일단 일치하는 것이 발견되면 더 이상 패턴을 검사하지 않고 종료한다.
	- pattern으로 애스터리스크(*)를 사용하면 프로그래밍 언어에서 사용하는 default 키워드와 경우가 같다.
	- 파이프(|) 기호를 사용하면 여러 패턴을 or로 조합하는 것이 가능하다.
	- 패턴과 명령어 사이에 ')' 문자를 넣어야 한다.

02. 패턴의 사용 예
	- a)	: a인 경우
	- [[:alpha:]]	: 1개의 알파벳 문자인 경우
	- ???)	: 임의의 세 글자인 경우
	- *.txt)	: .txt로 끝나는 경우
	- [aeiou]: 모음에 해당하는 영문 소문자 1개인 경우
	- [ABE][0-9]	: 앞 글자가 A, B, E 중 하나이고 다음 글자가 숫자인 두 글자
	- *)	: 임의 길이의 글자와 매칭. case명령에서 마지막 패턴으로 사용하는 것이 좋음


	11.5 반복 구조
00.
반복 구조를 이용하면 모든 데이터가 처리될 때까지, 조건이 만족하는 동안 계속해서 또는 조건이 만족될 때까지 계속해서 정해진 일련의 명령어를 반복적으로 수행할 수 있다. 이것을 위해 제공하는 반복 제거 구조가 각각 'for ... do',	'while ... do',	그리고 	'until ... do' 제어 구조이다.

01.
for ...do	제어 구조는 for 명령으로 구현된다. for 명령은 두 가지 형태로 제공되는데, 일반적인 형태는 다음과 같다.

	for variable [in word...]; do
		command...
	done

여기에서 variable은 변수의 이름이며, word...부분은 값의 목록이다. 즉 변수 variable에 word 목록에 존재하는 값들을 순차적으로 하나씩 대입하고 do와 done 사이의 명령을 수행한다. 만약 in word...부분이 없다면 in "$@"가 있는 것으로 가정한다. 즉, 셸 스크립트를 실행하면서 인수를 사용하여 word 목록을 제공할 수 있다.

02.
for 문의 두 번째 형태는 C 언어를 포함한 여러 프로그래밍 언어에서 제공하는 for문과 유사한 형태이다.

	for (( exp1; exp2; exp3 )); do 		exp1: 초기화(i=0;) 	exp2: 명령이 계속될 조건(i > 10;) 	exp3: 반복 조건
		command...	: exp2가 참인 경우에 수행해야 할 명령
	done

이 명령을 while 명령으로 바꾸면 다음과 같다.
	
	((exp1 ))
	while ((exp2 )); do
		command ...
		((exp3))
	done



	2. while 과 until 명령

00.  
'while ...do' 제어 구조는 while 다음에 나오는 명령을 수행하여 종료 상탯값이 0이면, 즉 참이면 do와 done 사이의 명령을 수행한다. 이후 다시 while 다음에 나오는 명령을 수행하여 do와 done 사이의 명령을 반복할지 결정한다. if 명령에서와 마찬가지로 종료 상탯값이 0인 경우 참으로 판단한다. 따라서 if 명령처럼 while 다음에 나오는 명령으로 	test expression 또는 	[ expression ]과 같은 명령어를 자주 사용한다. 형식은 다음과 같다.

	while	command ...; do
		command ...
	done
01.
(( expression ))은 수식 계산에 사용되는 복합 명령이며, 이것의 결괏값을 참 또는 거짓의 판별에 사용할 수도 있다. 이것은 셸의 내장명령 let을 사용하여 let "expression"으로도 작성할 수 있다. (expression에 공백이 없으면 큰따옴표는 없어도 된다). 이때는 수식의 결과가 0인 경우 거짓으로, 0이 아닌 경우 참(상탯값이 0)으로 판단한다. while 명령의 조건을 표시학시 위해 test 명령 대신에 사용할 수 있으며 if 명령의 조건을 표시하기 위해서도 사용할 수 있다. 

02.
until 명령은 until 다음에 나오는 명령을 수행하여 종료 상탯값이 0(참)일 때까지 반복한다. 다시 말해 종료 상탯값이 0이 아닌 경우, 즉 거짓인 동안 반복한다. while 명령처럼 조건을 표시하기 위해 test expression이나 [ expression ] 또는 (( expression ))을 사용할 수 있다, 형식은 다음과 같다.

	until	command...; do
		command
	done

##	#!/bin/bash 	이 한 줄은 “셸 스크립트의 첫 줄(shebang)” 이라고 부르는 부분입니다.
### /bin/bash : 스크립트를 실행할 때 사용할 명령 해석기(interpreter) 의 경로를 뜻합니다. 즉, 이 스크립트는 Bash 셸로 실행된다는 의미예요.
	1) 리눅스는 스크립트를 실행할 때 첫 줄을 확인합니다.
	2) 만약 #! 로 시작하면, 뒤에 적힌 경로의 프로그램(여기서는 /bin/bash)을 이용해 나머지 스크립트를 해석하고 실행합니다.

🧩 정리 01 : 0인 참인 경우와 거짓인 경우1

구분				기준			"0"의 의미

일반 명령 (ls, grep, test 등)	exit status (종료 코드)	참(true)
let 명령			계산 결과값		거짓(false)

🧩 정리 02 : 0인 참인 경우 2가지 ("let"과 "((  ))")

구분					let					(( ))

쉘 내장 명령 (명령형)	✅ 있음 (/usr/bin/let)			❌ (문법 구조)

따옴표 필요				보통 필요함 (let "a=a+1")		불필요 ((( a=a+1 )))
변수 앞 $ 필요 여부		사용 안함 (let "a=a+1")			사용 안함 ((( a=a+1 )))
조건식에서도 사용 가능	가능하지만 구식	가능하고 더 현대적 	(if (( a < 10 )))
성능/가독성				다소 낮음						더 빠르고 표준적

🔸 정리하면 let은 오래된 문법이고, (( ))은 더 간결하고 현대적인 Bash 내장 산술 평가 문법입니다.

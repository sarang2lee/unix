제 12 장 버전 관리와 깃

00.
깃으로 버전을 관리하려면 작업 디렉터리, 스테이지, 저장소의 기능을 구분할 수 있고, 파일의 상태 변화 과정을 이해해야 한다. 깃 저장소에 기록된 커밋 이력을 통해 시간 이동을 하고, 커밋 간 저장된 파일을 비교하는 깃 명령을 살펴 본다.


	12.1 버전 관리
	12.2 깃(Git)

00.
대표적인 오픈소스 버전 관리도구로는 CVS(Current Versions System)와 SVN(Subversion)과 같은 중앙집중형 버전 관리 시스템이 있고, 머큐리얼(Macurial)과 바자(Bazaar), 깃(Git)과 같은 분산형 버전 관리 시스템이 있다. 깃은 버전 관리 소프트웨어에 중 가장 많이 사용되는 프로그램으로 리눅스 커널 개발에 사용되었다.

	1. 깃의 역사와 특징

00.
깃은 빠르며, 네트워크가 끊겨도 작업이 가능하고, 잘못한 작업을 취소할 수 있으며, 변경 사항 추적을 위해 상태를 파악하고 파일을 비교하는 등의 여러 기능을 제공한다. 
	1) 소스 코드의 변 사항을 추적할 수 있다.
	2) 분산환경하의 여러 개발자가 독립적으로 작업할 수 있다.
	3) 여러 개의 평행 브랜치를 통해 다양한 작업을 동시에 처리할 수 있다.
	4) 스테이징 영역을 이용하여 변경 사항 중 커밋할 부분을 선택할 수 있다.


	2. 분산형 버전 관리와 중앙집중형 버전 관리

00. 저장소
분산형 버전관 시스템(DVCS: Distributed Version Control System)에는 서버에 존재하는 원격 저장소와 각 개발자의 컴퓨터에 저장되는 지역 저장소가 있다. 모든 지역 저장소는 완전한 이력과 버전 추적 등의 모 기능을 갖춘 저장소로 중앙의 원격 저장소와는 독립적으로 동작한다. 이들 저장소 간에는 파일의 동기화(synchronization)를 통해 필요한 버전 관리를 수행한다.

01.
모든 지역 저장소는 중앙 서버에 있는 소스 코드를 가져와 지역 복사본을 만들 수 있으므로 거의 모든 작업을 지역에서 진행할 수 있다. 즉 작업을 수행하기 위해 항상 원격 저장소에 연결되어 있지 않아도 가능하다. 분산형 버전관리 시스템의 장점을 살펴보면 다음과 같다.
	1) 중앙 서버에 문제가 생겨도 클라이언트 컴퓨터에 있 소스를 통해 원상 복구가 가능하다.
	2) 여러 명이 동시에 작업하는 병렬 개발이 가능핟.
	3) 풀(pull)과 푸시(push) 작업에만 인터넷 연결이 필요하고, 대부분 작을 오프라인 상태에서도 지역에서 수행할 수 있다.
	4) 프로젝트를 모두 복사한 후 지역 환경에서 쉽게 점검할 수 있다.

02.
커밋(commit)은 변경 사항을 반영하는 것 또는 변경된 파일을 기록해 두는 것을 의미한다.

	3. 깃 설치

00.
윈도우에서 깃을 사용하는 경우 '깃 배시(Git Bash)' 프로그램을 사용할 수 있다. 깃 배시는 깃 명령 실행을 위한 '명령행 인터페잇'를 제공하는 셸 프로그램으로 Bash 셸을 윈도우에서 사용할 수 있도록 해 준다. 리눅스에서는 	dnf install git	명령으로 설치할 수 있고, 기본 패키지에 들어 있다.

	4. 깃 설정
00.
깃 설정에는 시스템 설정, 전역 설정, 지역 설정의 세 가지가 있다. 
 - 시스템 설정: 해당 시스템에 있는 모든 사용자와 모든 저장소에 적용되는 설정이다. 
                리눅스에서 설정 내용은 	/etc/gitconfig 파일에 저장되며, git config 명령에서 --system 옵션을 사용한다.
 - 전역 설정: 해당 사용자에게만 적용되는 설정으로 명령에서는 --global 옵션을 사용하며, 설정 내용은 	~/.gitconfig 파일에 저장된다.
 - 지역 설정: 사용자가 작업 중인 현재 지역 저장소에만 적용되는 설정으로 명령에서 --local 옵션 사용하거나 기본 옵션이므로 생략 가능하다. 
              설정 내용은 지역 저장소 '깃 디렉터리'에 있는 .git/config 파일에 저장된다.
01.
깃 설정에서 중복된 설정이 있다면 지역 - 전역 - 시스템 순으로 우선한다.

02.
깃 저장소가 생성되면 초기 브랜치(brabch) 이름은 master로 설정되는데, 기본(default) 브랜치 이름을 다르게 설정할 수도 있다. 해당 설정 변수는 init.defaultbranch이며, master대신 자주 사용되는 이름은 main, trunk, development 등이다. 물론 생성된 이후에도 	git branch -m name 명령을 사용하여 브랜치 이름을 변경할 수 있다.

## 브랜치란 독립적으로 개발되고 있는 순서가 있는 일련의 커밋 목록을 말한다. '브랜치 이름'은 브랜치에서 가장 최신(마지막) 커밋을 가리키는 포인터이다.


	12.3 깃 사용하기

	1. 깃 저장소

00. 깃 저장소 지정:	git init [directory]
깃으로 관리하려면 먼저 특정 '작업 디렉터리'를 '깃 저장소'로 지정해야 한다.	명령어는 	git init [directory]	이다.

01. git status 명령
	1) git status [--long]	: 기본 옵션이며 현재의 상태를 자세히 표시한다.
	2) git status (--short | -s) 	: 현재의 상태를 간단히 표시한다.
	3) git status (--help | -h)	: 도움말을 보여준다.

02. ('add' = tracked = staged)
깃으로 파일의 변경을 추적하고 관리하려면 파일을 '추적되는 파일(tracked file)'로 바꾸어야 한다. 처음 만든 추적되지 않는 파일을 명령 git add	를 사용하여 '추적되는 파일'로 변경할 수 있다.
	1) git add files	: 파일을 스테이지 영역에 추가한다.
	2) git add .		: 현재 디렉터리와 하위 디렉터리에서 모든 파일을 스테이지 영역에 추가한다.
	3) git add (--all | -A)	: 전체 작업 영역의 모든 파일을 스테이지 영역에 추가한다.

03. (rm --cached = untracted = not staged = not indexed)     추적되지 않는 상태로 되돌리기:	git rm --cached file
파일을 추적되지 않는 상태 되돌리려면 git rm --cached file을 사용한다. 옵션 --cached를 사용함으로써 cache 상태에서 삭제한다는 의미인데, chche는 스테이지 영역(또는 인덱스)을 의미한다. 다시 인덱스에 등록하고 옵션 -s(또는 --short) 파일의 상태를 확인하면, 'added'의 의미인 A로 표시된다.


	2. 작업 디렉터리, 스테이지 영역, 깃 저장소

00.
'작업 영역(working area)'은 파일을 만들고 변경할 때 우리가 사용하는 리눅스 디렉터리이며, 작업 트리(working tree), 작업 디렉터리, 작업 폴더, 프로젝트 폴더라고도 한다. '스테이지 영역(staging area)'은 작업 영역과 깃 저장소 사이에 존재하는 공간으로 스테이지(stage) 또는 인덱스(index)라고도 하며, 선택된 개별 파일의 변경 내용을 기록하는 가상의 공간이다. '깃 저장소'는 버전이 만들어지고 관리되는 가상의 공간으로, 필요할 때 특정 시점에서 커밋을 수행하여 스테이지의 스냅숏(snapshot)을 저장한다. 즉 시간이 흐름에 따라 수행되었던 여러 커밋이 연결되면서 커밋의 이력이 형성되고 관리된다.

01.
깃에서 커밋을 실행하려 할 때 작업 영역에 있던 변경 내용을 바로 깃 저장소에 기록하는 것이 아니라, 그 전에 변경된 파일을 스테이지 영역에 기록해야 한다. 이 작업을 '스테이징(staging)', '스테이지에 올린다' 또는 '인덱스에 등록한다'고 한다. 즉, 깃 저장소에 버전을 기록하려면 그 전에 기록하고자 하는 파일을 선택하고 그것의 변경 사항이 스테이지 영역에 올라와 있어야 한다.

02. 파일의 상태 변화
먼저 작업 영역에 존재하는 파일의 상태는 '추적되지 않음(untracked)' 상태와 '추적됨(tracked)' 상태로 나뉜다. 
'수정 전(unmodified)', '수정함(modified)','스테이지에 올라옴' 상태는 모두 '추적' 상태의 하나이다.

03. 추적되지 않음 -- (git add file) -- 추적됨(staged) -- (git commit) -- 커밋 후 수정 전 상태 -- 커밋 후 수정함 상태 -- (git add) --(git commit) ... 
03-01: not tracked -- (git add) -- tracked(staged-unmodified) -- tracked(staged-modified) -- (git commit) -- not tracked(unmodified) -- 
		   -- (git add) -- tracked(staged-unmodified) -- tracked(staged-modified) -- (git commit) -- not tracked(unmodified) -- ....
		
		## 단, git add와 git commit는 동시에 수행이 가능하다.


	3. 커밋과 커밋 이력

00. commit
커밋(commit)은 버전 관리를 위해 현재 스테이지 영역에 있는 파일의 내용에 대해 스냅숏을 찍는 명령이다. 즉, 버전 관리를 위해 인덱스에 등록된 파일의 현재 상태를 커밋으로 기록한다. 인덱스에 등록된 파일의 변경사항을 깃 저장소에 커밋으로 기록해 두는 것이다. 
커밋 이력을 관리하기 위해 반드시 커밋마다 의미가 명료한 '커밋 메시지'를 가지고 있어야 한


01. git commit 명령

	- git commit		: 커밋을 실행한다. 편집기를 열어 커밋 메시지를 입력하게 한다.
	- git commit -m message	: 커밋 메시지를 지정하여 커밋을 실행다.
	- git commit -a -m message	: 인덱스에 등록 커밋을 함께 실행한다. git에 알려진 적이 없는 새 파일은 커밋할 수 없다.
	- git commit -am message	: 위와 동일하다.

02.  git log	: 커밋 이력 보기
커밋 이력은 git log 명령으로 확인할 수 있는데, 기본적으로 현재 브랜치에서 최신 커밋부터 순서대로 커밋 정보를 나열한다.

	- git log		: 현재 브랜치의 커밋 정보를 나열하여 커밋 이력을 표시한다.
	- git log --oneline	: 커밋 정보를 한 줄로 표시한다. 
	- git log (--patch | -p): 커밋 정보에 파일의 변경 내용을 표시한다. 
	- git log --graph	: 문자를 연결하여 그래프 커밋 이력을 그린다.
	- git log --reverse	: 오래된 커밋부터 표시한다. --graph와 함께 사용할 수 없다. 
	- git log --all		: 모든 브랜치의 커밋 이력을 표시한다. 
	- git log -n		: 최근 n개의 커밋 이력 표시한다.

03. git show	:특정 커밋의 정보 보기

	-git show [HEAD]	: git show HEAD		HEAD가 가리키는 커밋의 정보를 표시한다.
	-git show HEAD~		: git show HEAD~	HEAD가 가리키는 커밋의 직전 커밋 정보를 표시한다.
	-git show --oneline	: git show --oneline	커밋 로그 한 줄과 파일 차이를 표시한다.
	-git show -s		: git show -s		커밋 로그 한 줄은 표시되지만, 파일 차이는 표시지 않는다.
	-git show commit	: git show commit	인자로 주어진 커밋의 정보를 표시한다.

04. @@ -1,2 +1,4 @@의 의미	: 원래 파일의 1번째 줄부터 2줄이었는데, 1번째 줄부터 4줄이 되었다. 빠진(-)줄과 추가(+)된 줄은 다음과 같다.

05. 반대 명령어

	- 스테이지에 올리기(=tracked)		: git add file
	- 스테이지에서 내리기(=untraked)	: git reset file  (= git restore --staged file )

06. 로컬 저장소에서 기본 브랜치 이름 변경	: git branch -m master main



	12.4 버전 여행

	1. HEAD
00.
일반적을호 HEAD는 현재 작업 중인 브랜치에서 가장 최신 커을 가리킨다. 하지만 깃 명령을 사용하여 HEAD를 다른 브랜치로 이동시키거나 특정 커밋을 가리키게 할 수 있다. 즉 HEAD는 시간 이동을 위한 수닺이다. 또한 ~(틸드)와 ^(캐럿)을 사용하면 HEAD의 위치를 기준으로 다른 커밋을 가리킬 수 있다.
예를 들어 HEAD~는 HEAD가 가리키는 커밋의 직전 커밋을 가리킨다. ~를 여러 개 사용할 수 있는데 HEAD~~는 직전의 직전 커밋을 가리킨다. HEAD는 숫자와 조합해 HEAD~2 처럼 사용 가능하며 이는 HEAD~~와 같다. HEAD^는 HEAD~와 같지만 HEAD^다음에는 숫자 1밖에 오지 못한다. 반면에 HEAD~ 뒤 숫자는 제한이 없다.

	2. 체크아웃	: HEAD 이동 명령어

00. git checkout 명령
명령 git checkout으로 HEAD를 과거 커밋 또는 다른 브랜치의 최신 커밋으로 이시키면 그 커밋에 기록된 파일의 내용을 확인할 수 있다. 

	- git checkout HEAD~	: HEAD를 직전 커밋으로 이동시킨다.
	- git checkout ~	: 직전 브랜치로 이동한다.
	- git checkout branch	: 주어진 브랜치로 이동한다.


	3. 저장 공간 간 파일 비교

00.
깃에는 디렉터리, 스테이지 영역(또는 인덱스), 깃 저장소의 세 가지 저장 공간이 있다. 이들 파일 내용 차이를 비교하는 명령이 git diff이다. 비교되는 두 파일이 같으면 출력 결과에 아무것도 표시되지 않는다. 여기서 HEAD는 최신 커밋을 가리킨다고 가정한다.

01.
명령 git diff 		는 파일 내용의 차이를 표시하는데, 스테이지 영역을 기준으로 작업 디렉터리의 내용을 비교한다. 
명령 git diff --staged 	는 깃 저장소의 최신 커밋에 기록된 파일의 내용과 스테이지 영역에 기록된 파일의 내용을 비교한다. --staged = --cached

02.
명령 git diff HEAD	는 깃 저장소에서 최신 커밋에 기록된 파일의 내용을 기준으로 작업 디렉터리에 저장 파일의 내용을 비교한다.
명령 git diff HEAD~2	는 깃 저장소에서 최근 커밋의 전전 커밋과 작업 디렉터리에 기록된 파일의 내용을 비교한다.


	4. 버전 간 파일 비교

00.
명령 git log --oneline -p	를 실행해 보면 앞뒤 커밋 간에 기록된(=커밋된) 파일의 차이를 확인할 수 있다.
명령 git diff HEAD HEAD~	는 직전 버전을 기준으로 최신 버전 어떻게 변경되었는지 보여준다.

01. 버전간 비교 명령은 다음과 같이 두 가지 형식이 있다.
	git diff commit1 commit2	HEAD 대신에 직접 커밋 아이디를 사용해 비교하는 것도 가능하다.
	git diff commit1..commit2	ex) git diff e017c06 35a1218

02.
명령 git diff HEAD~2 HEAD	는	git diff HEAD~2..HEAD	또는	git diff HEAD~2..	과 같다. ..이후는 HEAD가 생략된 것으로 간주한다.

03. git diff	명령의 결과 보여주는 텍스트 칼라의 의미
	- 빨간색	: 삭제된 내용	'-' 기호로 시작, 이전 버전에서는 있었지만, 새 버전에서는 사라진 줄
	- 초록색	: 추가된 내용	'+' 기호로 시작, 새 버전에서 새로 추가된 줄
	- 흰색 또는 회색	: 변경되지 않은 내용	문맥 보여주기 위한 주변 코드(비교의 기준선)
	- 노란색 또는 주황색	: 수정된 영역 강조	일부 터미날에서는 변경된 단어(문자수준) 부분을 색으로 표시

	
	5. 단순 파일 비


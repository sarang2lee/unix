제 8 장 파일시스템 관리


01.
디스크에 데이터를 저장하기 위해서는 먼저 파티션을 만들고, 파티션에 파일 시스템을 만들어 주어야 한다. 또한 저장장치를 사용하기 위해서는 전체 디렉터리 트리(또는 전체 파 시스템 트리)의 어딘가에 붙여야 하는데, 이를 마운트(mount)라고 한다.
즉, 저장장치에 파티션이 존재하며 여기에 파일 시스템이 만들어져 있을 때, 각 파일 시스템을 전체 트리 구조에 부착하여 운영체제에서 사용할 수 있게 하는 것이 mount이다.

02.
가상 파일 시스템: swap, tmpfs, prpc, sysfs, devpts
단순히 mount 명령만으로 출력되는 결과는 etc/mtab 파일에 기록된 내용과 사실상 같다. 실제 마운트와 언마운트를 위해 mount 또는 unmount 명령을 내리면 그 내용이 /etc/mtab 파일에 기록된다. 단, mount 명령에서 -n 옵션을 사용하면 /etc/mtab 파일에 기록되지 않는다.

03. 
/etc/fstab에서 사용하는 마운트 옵션

  1) defaults: rw, suid, dev, exec, auto, nouser, async가 적용된다. 
	auto	: 부팅시 자동으로 마운트된다. 반대는 noauto이다.
	exec	: 바이너리 파일의 실행을 허용한다. 반대는 noexec이다.
	suid	: setUID와 setGID가 효력을 발생한다. 반대는 nosuid이다.
	rw	: 읽기와 쓰기가 모두 가능하게 파일 시스템을 마운트한다. 반대 ro이다.
	user	: 일반 사용자도 마운트할 수 있게 한다. 반대는 nouser이며, 이는 root 사용자만 마운트가 가능하게 한다.
	remount	: 이미 마운트되어 있는 경우 다시 마운트한다.

04.
일반적인 마운트 방법은 다음과 같다.

	mount [options] [-t type] [-o mount_options] device directory

05.
mount 명령의 옵션(options)
	-a	: /etc/fstab에서 나열된 모든 파일 시스템을 마운트한다.
	-t type	: 파일 시스템의 유형을 지정한다.
	-o M_option	: 마운트 옵션을 지정한다. 여러 옵션은 콤마(,)로 구분한다.
	-f	: 실제로 마운트하지 않고 마운트 가능한지 점검한다.
	-n	: 마웅ㄴ트 내용을 /etc/fstab에 기록하지 않는다.
	-r	: 읽기 전용으로 마운트한다. -o ro와 같은 의미이다.
	-w	: 읽기와 쓰기가 가능하게 마운트한다. -o rw와 같은 의미이다.

06.
mount 명령 사용하기

  1) mount 명령을 사용하기 전에 마운트 지점으로 사용될 디렉터리를 먼저 생성해야 한다.

	mount -r ext4 /dev/sdb1 /mnt/data1

  2) mount 명령을 사용하면 우선 /etc/fstab 파일에서 해당 파티션의 파일 시스템에 지정된 옵션을 적용한 후 -o 옵션에서 주어진 것을 적용하고, 끝으로 -r 또는 -w 옵션이 있다면 그것을 적용한다. 예를 들어 CD-ROM을 마운트하려면 다음과 같이 할 수 있다.

	mount -t iso9660 -o ro /dev/sr1 /media/cd

  3) mount를 할 때 구별할 필요가 있는 경우가 아니라면 반드시 -r 옵션이나 -o 옵션을 사용해야 하는 것은 아니다. -t 옵션이 주어지지 않거나 -t 옵션에서 유형의 값으로 auto가 주어지면 /etc/fstab 파일이나 파티션의 슈퍼블록을 조사하여 커널이 유형을 결정한다. 

07.
umount 명령

  1) 언마운트를 위한 명령은 umount이다. unmount가 아니라 umount이다. 사용법은 다음과 같다.

	umount -a [-nv] [-t fs_type]
	umount [-nv] devicedirectory

  2) 언마운트는 마운트된 파일 시스템을 전체 디렉터리 트리로부터 해제시키는 명령이다. 다음의 예는 /etc/mtab 파일에 명시된 파일 시스템 중에서 유형이 iso9660인 파 시스템을 모두 언마운트 한다.

	umount -a -t iso9660

  3) DVD나 CD-ROM은 마운트된 상태에서 디스크를 꺼낼 수 없다. 또한 USB 메모리를 꺼낼 때는 반드시 언마운트한 후 꺼내야 데이터의 손실을 막을 방지할 수 있다.


08.
파티션 관리

파티션이란 저장장치에서 고정 크기의 일부 영역이다. 하나의 물리적 저장장치에 여러 개의 파티션을 만들 수 있으며, 각 파티션은 자신만의 디바이스 파일(/dev/...)을 가지고 있다. 따라서 하나의 파티션을 마치 독립적인 저장장치처럼 사용할 수 있다. 파티션은 하나의 물리 디스크를 논리적으로 나눈 구역을 말하는데, 분할된 하나의 파티션은 하나의 독립적 디스크처럼 사용할 수 있다.

리눅스는 파티션을 표현할 때, 디스크 전체를 표시하는 블록 디바이스 파일의 이름 뒤에 숫자를 붙여 표시한다. 예를 들어 SCSI 디스크를 표현하는 이름인 /dev/sda의 뒤에 숫자를 붙여 /dev/sda1과 /dev/sda2오 같이 디스크의  첫 번째 파티션과 두 번째 파티션을 표현한다. 전체 디스크와 마찬가지로 각 파티션도 블록 디바이스이다. 

(swap 파티션) 리눅스에서는 운영체제 및 프로그램과 데이터를 저장하는 마운트 지점이 루트(/)인 표준 리눅스 파티션 외에 추가로 스왑(swap) 파티션이 반드시 필요하다. 여기서 스왑 파티션이란 프로그램 실행 시 메모리의 용량 부족을 하드디스크로 대신하기 위한 디스크 공간, 즉 가상 메모리로 사용되는 역을 말한다. 보토 메모리가 8~64G인 경우 4G 이상으로 1.5배까지 스왑(swap) 영역을 할당한다.


10.
파티션 관리도구

1) 최근 대부분의 운영체제는 GPT(Globally unique identifier Partition Table: 또는 GUID 파티션)를 지원한다. 리눅스 파티션 관리도구로는 다음과 같은 것이 있다.
	parted	: MBR과 GPT를 모두 지원하는 텍스트 기반의 대화식 도구
	gparted	: parted의 그래픽 버전
	fdisk	: 리눅스에서 사용되던 텍스트 기반의 전통적 파티션 관리도구로 GPT를 지원하지 않는다.
	gdisk	: fdisk와 유사하나 MBR이 아닌 GPT를 지원하는 버전

2) 많은 사람이 fdisk에 익숙해 있으나 MBR과 GPTf를 모두 지원하는도구인 parted를 사용하여 파티션을 관리하는 것도 좋은 방법이다. parted를 사용하여 파티션을 생성하거나 복사 또는 삭제하고, 파티션의 크기를 변경하며, 파티션을 이동시키거나 할 수 있다. 

3) parted를 사용하여 파일 시스템을 생성하거나 파일 시스텐의 크기를 변경시키는 것 등의 파일 시스템 관리 작업도 할 수 있다. 그러나 파티션을 다루는 것과 파일 시스템을 다루는 것은 큰 차이가 있기 때문에 파일 시스템을 다룰 때는 혼란을 피하기 위해 parted가 아닌 다른 도구를 사용하는 것이 좋다.

4) 리눅스 시스템에서 현재 파티션 테이블의 정보를 보려면 관리자 권한으로 parted -l 또는 fdisk -l 명령을 실행한다. 

5) LVM은 Logical Volume Management에서 사용되는 파티션으로, 파티션의 크기를 축소하거나 확장할 수 있는 유연성을 제공한다. 

6) fdisk -l 명령은 파티션 테이블의 정보를 보여 준다. 결과에서 파티션별로 ID값이 나타난다. 83은 리눅스 파티션, 82는 리눅스 스왑 파티션, 8c는 리눅스 LVM 논리 볼륨을 의미한다.

7) parted 명령(관리자)

[202434-243396@localhost ~]$ sudo parted /dev/nvme0n1
GNU Parted 3.5
/dev/nvme0n1 사용법
GNU Parted 사용을 환영합니다! 명령 목록을 보려면 ‘help’를 입력하십시오.
(parted) help                                                             
  align-check <형식> <번호>                       <번호> 분할 영역의 지정 <형식>(min|opt) 정렬
        상태를 검사합니다
  help [<명령>]                           일반 도움말 또는 <명령> 도움말을 출력합니다
  mklabel,mktable <레이블 형식>              새 디스크 레이블(분할 영역 테이블)을 만듭니다
  mkpart <분할 영역 형식> [<파일 시스템 형식>] <시작> <끝>     분할 영역을 만듭니다
  name <번호> <이름>                         <번호> 분할 영역의 이름을 <이름>으로 지정합니다
  print [devices|free|list,all]     분할 영역 테이블, 존재 장치, 여분 공간, 발견한 모든 분할 영역을 나타냅니다
  quit                                     프로그램을 빠져 나갑니다
  rescue <시작> <끝>                         <시작> 및 <끝> 영역 주변의 소실 분할 영역을 복원합니다
  resizepart <번호> <끝>                    <번호> 분할 영역의 크기를 조절합니다
  rm <번호>                                <번호> 분할 영역을 삭제합니다
  select <장치>                            편집할 장치를 선택합니다
  disk_set <플래그> <상태>                      선택한 장치의 <플래그> 값을 바꿉니다
  disk_toggle [<플래그>]                       선택한 장치의 <플래그> 상태를 전환합니다
  set <번호> <플래그> <상태>                    <번호> 분할 영역의 <플래그> 값을 바꿉니다
  toggle [<번호> [<플래그>]]                   <번호> 분할 영역의 <플래그> 상태를 전환합니다
  type NUMBER TYPE-ID or TYPE-UUID         type set TYPE-ID or TYPE-UUID of
        partition NUMBER
  unit <단위>                                기본 단위를 <단위> 값으로 설정합니다
  version                                  GNU Parted의 버전 번호와 저작 정보를 나타냅니다
(parted) print
모델: VMware Virtual NVMe Disk (nvme)
/dev/nvme0n1 디스크: 42.9GB
섹터 크기(논리/실제): 512/B512B
분할 영역 테이블: msdos
디스크 플래그: 

번호  시작    끝      크기    형식     파일 시스템  플래그
 1    1049kB  1075MB  1074MB  primary  xfs          boot
 2    1075MB  42.9GB  41.9GB  primary               lvm

8) 파티션 테이블을 수정한 후에 grep sda /proc/partitions 명령으로 sda를 /pric/partitions에서 찾아보면 커널이 변경작업을 인지하고 있는지 확인할 수 있다. 파티션을 만든 다음에 파일시스템을 생성할 수 있다.


11. 볼륨관리

1) 디스크를 분할하여 생기는 하나하나의 영역을 파티션이라고 한다. 2개의 파티션에 서로 다른 운영체제가 설치되었다면 멀티부팅(또는 듀얼 부팅)이 가능하다.

2) 리눅스의 볼륨의 관리는 파티션이 가지는 제약 사항인 경계의 벽을 허무는 것이다.3) 물리 볼륨(PV, Physical Volume), 볼륨 그룹(Volume Group, 여러 물리볼륨을 하나로 묶은 개념, 논리 볼륨(LV, Logical Volume), 볼륨그룹에서 가용한 공간을 분할하여 만드는 것), (물리, 논리) 익스텐트(PE, LE Physical Extent, 데이터 묶음의 단위, 블럭과 유사)
4) 논리 볼륨을 만드는 과정
  - 기존 파티션을 초기화하거나 파티션을 새로 만들 때 lvm 유형으로 만든다.
  - 하드디스크의 파티션 불러 물리 볼륨(PV)으로 만든다.
  - 하나 이상의 물리 볼륨(PV)을 볼륨 그룹(VG)에 할당한다.
  - 볼륨 그룹(VG) 안에서 논리 볼륨(LV)을 생성하고 포맷한 후 마운트 지점을 지정한다.

5) LVM(Logical Volume Management)

LVM(Loigical Volume Management) 도구를 사용하면 여러 개의 저장장치 각각에 물리 볼륨을 만든 다음, 이것을 합쳐 볼륨 그룹, 즉 저장장치의 풀(pool)을 구축할 수 있다. 그 다음에 볼륨 그룹을 일종의 파티션으로 생각할수 있는 논리 볼륨으로 구성할 수 있다. 즉, 하의 논리볼륨에 존재하는 이터는 다수의 저장 장치에 걸쳐 존재할 수 있는 것이다. 논리볼륨은 PV create --> PV --> VG create --> VG --> LV create --> LV의 구조를 갖게 된다.

pvcreate는 LVM 물리 볼륨을 만드는 명령이죠. 그 과정에서 기존 파일시스템(exFAT, ext4, 등)의 메타데이터 영역을 덮어쓰고 초기화합니다. 즉, mkfs.ext4나 mkfs.exfat로 했던 포맷은 더 이상 의미가 없습니다.

pvcreate를 실행한 후에는 해당 디스크는 “파일을 직접 저장할 수 있는 공간”이 아니라 “LVM 볼륨 그룹에 소속된 블록 저장소”로만 인식됩니다. 다시 파일저장용으로 쓰려면 vgremove, pvremove 후 mkfs.exfat 등으로 재포맷 필요합니다.


12. 파일 시스템

파일 시스템은 저장 장치를 트리 형태의 디렉터리 구조로 조직화시키고 파일에 이름을 부여하여 저장하고 검색할 수 있게 하는 체계이다. 대부분의 운영체제에서 데이터의 저장단위는 파일이다.

1) UNIX 파일 시스템의 기본 구성 요소

  - 슈퍼블록: 파일시스템의 특징을 기한 레코드이다 여기에는 디스크 블록의 크기, 전체 블럭의 갯수, inode 테이블의 크기와 위치, 디스크 블록 맵(디스크 사용 정보), 첫 번째 데이터 블록의 주소, 블록 그룹의 크기와 같은 파일 시스템의 중요한 정보가 들어 있다.

  - inode 테이블: 디스크의 시작 분에 있는 고정된 크기의 블록 집합으로 전에적으로 'inode list'라고도 한다. inode는 파일의 이름을 제외한 파일의 모든 정보, 즉 inode 번호, 파일의 형태, 크기, 접근권한, 소유 UID와 GID, 수정 시간, 링크 수, 파일 주소(데이터가 존재하는 디스크 블록의 위치) 등의 정보를 갖고 있다. ls -i 또는 ls -il로 inode 번호를 확인할 수 있다.

  - 데이터 블록: 일반 파일 경우 데이터 블록에 실제 데이터가 저장된다. 디렉터리의 경우는 그것이 가지는 파일이나 서브디렉터리의 이름이 inode 번호와 함께 저장된다. 디렉터리는 단순히 파일 목록을 가지고 있는 파일로 간주된다. 

2) ext4 : 리눅스 전용 파일시스템

  - 최대 1EiB(1024^8 byte) 크기의 파일 시스템과 16TiB(1024^4 byte) 크기의 초대형 파일을 지원하고
  - 많은 수 서브디렉터리(64,000개)를 지원하며
  - 블록 매핑 대신에 익스텐스 개념을 사용하고, 오프라인이 아닌 온라인으 단편화 제거(defragmentation)를 지원
  - ext 계열의 파일 시스템 간에는 하위 호환성이 재한다. 
  ### 저널링이란 변경을 기록하는 로그(또는 저널)를 어 시스템의 비정상 종료 시 파일 시스템 복구를 쉽게 하는 방법으로 Reiser 파일 시스템에서 최초로 지원하였으며, ext2에 이 기능을 추가한 것이 ext3이며, ext3의 개선된 버전이 ext4이다.

3) ISO9660 :  CD-ROM과 같은 광학 디스크에서 표준으로 사용되는 파일 시스템

  - 데이터 공유가 가능하게 윈도우, macOS, 유닉스 계열의 서로 다른 운영체제를 지원한다.

4) FAT 계열: 과거 DOS나 윈도우 운영체제에서 많이 사용되었던 파일 시스템

  - 리눅스의 파일 시스템으로 사용하려면 최신 윈도우 운영체제의 파일 시스템 중에서 vfat을 사용하는 것이 좋다.

5) HFS+ : 애플의 HFS(Hierarchial File System)의 개선 버전으로, 대부분의 매킨토시 시스템에서 표준으로 사용된다.

6) Btrfs: B-tree file system의 약자이다. 개발중인 리눅스의 차세대 파일 시스템.

### XFS는 리눅스 진영에서 SGI(Silicon Graphics) 사가 1990년대 초에 개 고성능, 대용량, 서버용 파일 시스템으로 Rocky Linux는 이 파일 시스템을 사용한다. XFS는 완전히 독립적인 리눅스 고성능 저널링 파일 시스템이다. 


mkfs 명령:
파티션이나 논리 볼륨을 만들었으면 파일 시스템을 입힐 준비가 된 것이다.  mkfs 명령의 사용법은 다음과 같다.

	mkfs [-t fs-type] device     / mkfs -t ext4 /dev/sda1

ls -l /sbin/mkfs.*을 실행하여 결과를 확인할 수 있다.

파일시스템 검사: fsck
 - fsck는 파일 시스템의 무결성을 검사하는 것 이외에 손상된 파일 시스템을 수리하는 기능도 있다. 
 - 유닉스 계열의 운영체제에서 복구 작업을 할 때 손상된 파일은 각 파일 시스템의 최상위 디렉터리에 있는 lost+found 디렉터리에 두고 작없하는데, 만약 이 디렉터리에 많은 파일이 남아 있다면 손상된 파일이 많다는 증거이다. 
 - 저널링을 지원하 파일시스템(ext3, ext4, xfs)이라면 복구의 속도와 가능성이 높아질 수 있다.  

스왑영역:
특정 파티션이나 파일을 리눅스용 스왑 영역으로 지정하여 사용할 수 있다.  디스크의 일부를 '보조 메모리'로 지정해서 RAM처럼 쓰겠다는 것이다.
 - 컴퓨터는 RAM(주기억장치) 가 꽉 차면, 덜 중요한 데이터를 임시로 디스크에 내려놓습니다. 이때 내려놓는 디스크 공간이 바로 스왑 영역(swap space) 입니다. 즉, 스왑은 “RAM이 부족할 때 잠시 디스크 공간을 빌려 쓰는 완충지대”입니다.
 - 즉, 파티션을 스왑으로 사용한다는 의미는 하드디스크나 SSD의 일부 파티션을 따로 떼서 그 공간을 ‘스왑 전용’으로 예약해 놓는 것을 말합니다.
 - 스왑이 필요한 이유
   : RAM 부족 시 안정성 확보	메모리가 꽉 차면, 스왑에 임시로 데이터를 내려놓아 프로그램이 강제 종료되지 않음
     백그라운드 프로세스 보관	사용하지 않는 오래된 프로세스 메모리를 스왑으로 옮김
     하이버네이션(절전모드)	RAM의 내용을 그대로 스왑에 저장해야 하므로 반드시 필요

디스크의 남은 공간 보기: df -h
디스크의 사용 공간 보기: du 
   - 특정 파일 또는 디렉터리의 디스크 사용량을 알고 싶을 때는 du 명령을 사용한다. 


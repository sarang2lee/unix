제 3 장 셸 사용하기

00.
셸은 리눅스 사용을 위한 명령 행 인터페이스를 제공한다. 

	3.1 셸의 개요
00.
셸은 커널과 사용자 간의 가교 역할을 하는 명령어 해석기 또는 명령 행 인터페이스를 말한다. 셸이라는 단어는 커널을 감싼 껍질의 의미를 가진다. 셸은 명령어 해석기이면서 스크립트 언어이기도 하다. '셸 스크립트' 파일에 셸 명령어로 구성된 프로그램을 작성하면 셸이 스크립트 파일을 읽어 일련으 명령을 수행할 수 있다.

	1. 셸 사용하기
	2. 셸의 종류

00. 
Bash는 'Bourne Again Shell'의 약자이다. 1988년 브라이언 폭스(Brian Fox)가 Bourne Shell을 토대로 개발하였으며, C Shell 과 Korn Shell의 유용한 기능 가져와 통합시켰다. GPL 라이선스를 따른다.

01.
Bash Shell의 경우 기본 프롬프트는 $이며, 관리자 계정 즉 루트 사용자의 경우는 #이다. 서브 shell 진입하면 프롬프트가 >로 바뀐다. sub shell에서 본 shell로 돌아오는 명령어는 exit이다. 본 shell에서 exit를 치면 셸을 종료한다.
기본 shell을 바꾸는 명령은 chsh [options] [username]이다.

02.
명령의 종류(우선순위 별): 에일리어스 - 셸 예약어 - 함수 - 내장 명령 - 일반 명령 (에셸함내일)

03. 매뉴얼 페이지의 섹션 분류
	1: 사용자 명령
	2: 커널 시스템 호출(커널이 제공하는 함수)
	3: C 라이브러리 함수
	4: 디바이스 드라이버 정보
	5: 시스템 설정 파일의 형식
	6: 게임
	7. 파일 포맷, 인코딩
	8: 시스템 관리 명령

04.
명령어의 형식이나 옵션의 의미를 간단히 확인하려면 --help 옵션을 사용하는 것이 좋다. 예를 들어 	man mkdir	을 대신하여 	mkdir --help	를 사용할 수 있다. 매우 유용한 옵션이다.


	3.3 명령 히스토리

	history 10

00. history 기능을 사용하여 이전 명령을 실행하는 방법

	!!	: 직전에 수행하였던 명령이다.
	!n	: 히스토리 목록에서 번호 n에 해당하는 명령이다.
	!-n	: n 번째로 앞에 수행한 명령, !-1은 직적 명령이다.
	istring	: 지정 문자열로 시작하는 가장 최근의 명령이다.
	!?string	: 지정 문자열을 포함하는 명령 중 가장 최근 명령이다. 

01.
	1) 처음 몇 자만 타이핑한 후 Tab를 누르면 해당 문자가 포함된 명령어 리스트를 보여준다.
	2) 처음 몇 자만 타이핑한 후 Shift 키와 방향키를 누르면 이전에 실행했던 명령을 display해 준다.


	3.4 명령의 연결과 확장

00.
셸의 강력하고 유용한 기능 중 하나는 '명령어와 명령어' 사이에 또는 '명령어와 파일' 사이에 출력과 입력을 연결시켜 조합할 수 있다는 점이다. 이때 파이프와 입출력 리다이렉션을 위해 특수문 |, <,>, <<. >>가 사용된다.  한편 파일의 구룹을 지정할 때 *, ?, [], {}와 같은 와일드카드 문자를 사용할 수 있다. 


	1. 특수 문자

00. "\"
명령이 너무 길어 한 라인에 입력하기 힘들 때, 백슬래시(\)를 입력하고 Enter를 누르면 다음 라인에서 계속 명령을 입력할 수 있다. 

01. ";"
하나의 명령을 끝낸  다음 명령을 수행하는 것을 하나의 명령 행에서 수행할 수 있다. 이때 명령의 구분을 위하여 세미콜론(;)을 사용한다.

02. 셸에서 사용되는 특수 문자

 - 화이트스페이스	: Enter는 명령 행을 종료하고 명령을 실행시킨다. Space bar와 Tab은 명 행을 구성하는 요소를 분리한다.
 - 인용부호	: 작은 따옴표(' ')와 큰따옴표(" ")는 공백을 포함하는 문자열을 표시할 때나 특별한 의미를 가진 문자를 일반 문자로 처리하가 위해 사용한다. 역따옴표(` `)sms '명령치환' 기능을 수행한다.  
 - 백슬래시(\)	: 특수 문 앞에 붙어 특수 문자의 기능을 제거하며, 이스케이프 문자라고 한다. 또 긴 명령 행을 연장할 때도 사용한다. 그리고 alias된 명령 앞에 붙으면 alias를 없애 준다.
 - 틸드(~)	: ~ 또는 ~username은 사용자의 홈 디렉터리를 의미한다.
 - 도트(.)	: 현재 작업 디렉터리를 표시한다. 명령 행의 맨 앞에서 사용되면 셸 스크립트를 실행하는 source 명령과 같다.
 - 더블도트(..)	: 현재 디렉터리의 부모 디렉터리를 표시한다.
 - 달러($)	: $변수	는 변수의 값을 추출한다.
 - 파운드(#)	: # 문자의 뒤에 나타나는 문자를 주석으로 처리한다.
 - 앰퍼샌드(&)	: 명령&	는 명령을 백그라운드로 실행시킨다.
 - 애스터리스크(*)	: 파일 이름에서 사용할 때 임의 문자열과 대응된다.
 - 물음표(?)	: 파일 이름에서 사용할 때 1개의 문자와 대응된다.
 - 세미콜론(;)	: 여러 명령 순서대로 실행할 때 구분을 위해 사용한다. 한 개의 명령이 종료됨을 뜻한다.
 - 파이프(|)	: 왼쪽 명령의 출력을 오른쪽 명령의 입력으로 연결시킨다.
 - < 또는 >	: 입출력 다이렉션에서, 즉 파일로부터 입력을 받을 때 또는 파일로 출력할 때 사용한다.
 - >>	: 표준 출력을 파일의 끝에 덧붙일 때 사용한다.
 - 느낌표(!)	: 명령 히스토리 기능을 이용할 때 사용한다.
 - []		: 파일 이름을 지정할 때 대응되는 문자의 범위를 지정한다. 
		  예를 들어 [0-9]는 숫자 중 1개, [abc]는 a,b 또는 c 문자 중 하나와 대응된다.
 - {}		: 파일 이름을 지정할 때 대응되는 문자의 범위를 지정한다.
		  예를 들어 {one, two, three}와 {a, b}는 콤마(,)로 구분되는 것 중의 하나와 대응된다.

	2. 파이프와 입출력 리다이렉션

00.
명령을 수행할 때 필요한 입력을 표준입력(키보드)으로부터 읽어들이지 않고 파일로부터 입력을 얻으려면 왼쪽 화살표(<)를 사용한다. 예를 들어 sort < /etc/passwd	를 수행하면 표준 입력 대신에 지정된 파일 /etc/passwd 를 읽어 정렬한 후 화면에 출력한다. 파이프 연결은 계속 이어져도 된다. 즉 cat /etc/passwd | sort | more	으로 파이프를 연속해서 지정해도 된다.

01.
명령의 결과를 화면에 출력하지 않고 파일에 기록할 수 있다. 이때는 오른쪽 화살괄호(>)를 사용하는데, 표준출력(화면)을 지정된 파일로 리다이렉션하는 기능을 제공한다. 

02. 파이프와 입출력 리다이렉션

 - command > file	: 표준출력을 지정된 파일로 보낸다.
 - command 2 > file	: 표준 오류 출력을 지정된 파일로 보낸다.
 - command > file 2>&1	: 표준출력과 표준오류출력을 동시에 지정된 파일로 보낸다.
 - command < file	: 지정된 파일을 표준입력으로 지정하여 읽는다.
 - command < file.in >file.out	: file.in을 표준입력으로 지정하여 읽고 표준출력을 file.out으로 보낸다.
 - command >> file	: 표준출력을 지정된 파일의 끝에 덧붙인다.
 - command 2 >> file	: 표준오류출력을 지정된 파일의 끝에 덧붙인다.
 - command >> file 2>&1	: 표준출려과 표준출력을 지정된 파일의 끝에 덧붙인다.
 - command << c		: 지정된 문자가 나올 때가지 키보로부터 표준입력을 읽는다.
 - command1 | command2	: 앞 명령의 결과에서 표준 출력을 뒤 명령으로 연결한다.
 - command1 2>&1 |command2	: 앞 명령의 결과에서 표준출력과 표준오류 출력을 뒤 명령으로 연결한

	3. 명령 치환

00.
한 명령의 결과를 다른 명령의 인수로 사용하는 방법이 있다. 이것을 '명령치환(command substitution)'이라고도 하며 	$(command) 또는 `command`	형태를 가진다. 명령어 치환의 결과를 셸 변수에 저장할 수 있다.

	ls -l $(which passwd)
	$echo "There are $(ls | wc -w) files in this directory."

	4. 인용부호
00.
빈칸을 포함하는 문자열을 한 개의 인수로 사용할 때 인용부호(또는 따옴표)를 사용해야 한다. 특히 파일의 이름에 빈칸이 포함되는 경우 필요하다.
작은 따옴표(' ')를 사용하면 따옴표 안에 있는 모든 특수 문자의 의미를 제거할 수 있다. 즉 확장을 방지하고 문자 그대로 취급할 수 있다.

001. 큰 따옴표와 작은 따옴표로 감싸주면 여러 칸의 공백이 한 개의 공백으로 바뀌는 것도 막을 수 있다.

	echo "Here      is"	-->	Here     is
	echo 'Here      is'	-->	Here     is
	echo Here is		--> 	Here is
01.
큰 따옴표는 작은 따옴표와는 달리 예외적으로 달러($), 역따옴표(` `), 백슬래시(\) 문자를 해석하여 확장하며(=특별한 기능을 하도록 하며), 명령 히스토리에서 사용한느 느낌표(!)도 해석한다. 여기서 백슬래시(\)는 그 뒤에 $, `, ', " 또는 \ 문자가 나올 때만 특별 의미를 유지한다. 

	echo $(cal)		--> 	한 문장에 월 년 요일 날짜가 동시에 출력된다.
	echo "$(cal)"		-->	표 형식의 완벽한 달력이 출력된다.
	echo 'Today is $(date)	-->	Today is $(date)

	echo "!!"		-->	echo "echo 'Today is $(date)'
	echo '!!'		--> 	!!

	[202434-243396@localhost ~]$ echo 'Today is $(date)'
		Today is $(date)

	[202434-243396@localhost ~]$ echo "!!"
		echo "echo 'Today is $(date)'"
		echo 'Today is 2025. 10. 22. (수) 23:08:46 KST'

	## 작은 따옴표를 큰 따옴표로 묶으면 작은 따옴표는 문자 그대로 취급되어 특수기능 무력화 기능을 잃는다.

	5. 수식과 변수의 확장

00. 
수식의 결과를 명령에 전달하는 방법을 수식의 확장(arithmetic expansion)이라 하며 

	$[expression] 	또는 	$((expression))	형태를 가진다.

	echo BASH	-->	BASH
	echo $BASH	-->	/usr/bin/bash
	ls -l $BASH	-->	-rwxr-xr-x. 1 root root 1389024  4월 30  2024 /usr/bin/bash

	## echo $BASH 와 ls -l $BASH는 명령의 실행 전에 '변수 확장'이 먼저 이루어져 각각 echo /bin/bash	와 ls -l /bin/bash	가 실행된다.


	3.5 셸 변수

00.
셸은 '셸 변수'를 사용하여 정보를 저장할 수 있는데, 셸 변수는 문자열 정보를 갖는다. 
현재 사용 중인 셸에서 설정되어 있는 모즌 변수를 확인하려면 옵션이나 인수를 사용하지 않고 그냥 set 명령을 사용한다.

	1. 환경변수(environment variable)

00.
환경변수는 보통의 셸 변수와는 다르게 현재 셸로부터 새로운 서브셸이 만들어질 때 전달되는 변수를 의미한다. 환경변수가 아닌 셸 변수는 현재 셸에서만 유효한 지역변수라고 할 수 있다. 반면에 환경변수는 현재 셸과 그것의 서브셸에서 공통적으로 사용할 수 있는 전역변수라고 할 수 있다. 보통 환경변수의 이름은 대문자를 사용한다. 단순히 env 또는 printenv 명령을 사용하면 모든 환경변수와 그 값을 출력한다.

01.
셸 변수를 설정하고 값을 지정하려면 등호(=)를 사용한다. 이 변수를 환경변수로 지정하려면 export variable 명령을 사용한다.

02. 자주 사용되는 일반적 환경변수

	BASH	: bash 명령의 완전한 경로로 대개 /bin/bash이
	HISTCMD	: 히스토리 목록에서 가장 최근의 목록을 표시하는 번호이다.
	HOME	: 홈 디렉터리이다.
	MAIL	: 메일 박스 디렉터리에 해당하는 파일로 보통 /var/spool/mail/username이다.
	OLDPWD	: cd 명령을 사용하기 직전 작업 디렉터리이다.
	PATH	: 명령을 수행할 때 실행 파일을 찾기 위한 디렉터리 목록이다. 디렉터리는 콜론(:)으로 구분되어 설정된다.
	PS1	: 셸 프롬프트를 표시하기 위한 문자열이다. 명령어 수행 시 추가로 프롬프트가 필요한 경우 PS2, PS3 등을 설정하여 사용한다.
	PWD	: 현재 작업 디렉터리이다.
	PPID	: 셸의 부모 프로세스 ID이다.
	SHELL	: 사용 중인 기본 셸이다.
	USER	: 사용자 계정을 의미하는 이름이다.
	UID	: 현재 사용자의 ID이다.
	IFS	: 내부 필드 구분자라고 하며, 공백 문자, 탭 문자, 개행 문자를 기본값으로 가진다. 셸 내장 명령인 read 명령으로 읽은 행을 단어로 분리할 때나 확장 후에 단어를 분리할 때 기준으로 사용하는 문자를 의미한다.

03. 사용 예

	[\u@\h \W]\$	=	PS1	--> \u는 사용자계정, \h는 호스트 이름, \W는 현재 작업 디렉터리, \$는 달러 문자를 의미한다.

	이외에도 명령 히스토리 번호를 의미하는 \!	백슬래시를 표시하기 위한 	\\	날짜를 표시하는 	\d	시간을 표시하는	\t	현재 작업 디렉터리의 완전한 경로를 표시하기 위한 \w 등을 사용할 수 있다.
	 

	2. 로그인 환경 설정 파일

00.
사용자 계정과 암호를 정확하게 입력한 후 로그인에 성공하면 셸이 자동로 수행될 수 있다. 이를 '로그 셸'이라고 한다. 로그인 셸에서만 logout 명령을 사용하여 로그아웃을 할 수 있다..

01. 
GNOME을 사용한 GUI 환경에서 터미널 을 뛰우면 셸이 수행되는데, 이는 로그인 셸이 아니다. (이미 로그인한 상태이다)  셸에서 su -l username	을 수행하면 지정된 사용자 계정으로 로그인할 수 있으며, 이때 수행되는 서브셸은 로그인 셸이다.

02.
'로그인할 때' 또는 '로그인 후 셸을 시작할 때' 환경 설정을 위해 자동으로 수행되는 설정 파일이 존재한다. 이것은 개별 사용자를 위한 초기화 스크립트로 개별 사용자가 자신의 의도한 대로 환경을 설정할 때 사용한다.

03. 셸을 시작할 때 수행되는 초기화 스크립트

03-01	/etc/profile
모든 사용자에게 적용되는 시스템 수준의 환경 설정 파일로 로그인할 때 가장 먼저 수행된다. 루트 사용자만 수정할 수 있으며 PATH, MAIL, HISTSIZE 등 전역의 환경변수가 일반적으로 설정된다.

03-02	~/.bash_profile
로그인할 때 수행되며, 개별 사용자에게 적용되는 환경 설정 파일이다. 새롭게 환경 변수를 설정할 수 있으며, 보통 내부에서 ~/.bashrc	를 실행한다. 이 파일에서 설정된 변수는 든 셸에 전달되어 로그아웃할 때까지 유효하다.

03-03	~/.bashrc
로그인 후 셸을 시작할 때 수행되며, 개별 사용자에게 적용되는 설정 파일이다. 보통 내부에서 /etc/bashrc	를 수행한다.

03-04	/etc/bashrc
로그인 후 셸을 시작할 때 가장 먼저 적욛되며, 모든 사용자에 적용되는 설정 파일이다. 루트 사용자만 수정할 수 있으며, 프롬프트를 정하는 PS1, alias를 이용한 에일리어스 설정, umask를 사용한 접근권한의 초깃값 등 일반적 설정을 수행한다.

03-05	~/.bash_logout
로그아웃을 수행할 실행되는 스크립트 파일이다.



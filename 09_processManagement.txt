9.1 프로세스

00.
 - 프로세스란 커널의 관리하에 있으면서 여러 상태 변화를 겪는 실행 중인 프로그램을 말한다.
 - systemd 프로세스를 포함하여 많은 시스템 서비스는 백그라운드로 수행되는 데몬 프로그램 형태이다. 

01. 
커널은 등록된 프로세스를 관리하기 위해 '프로세스 컨트롤 블록(pCB 또는 프로세스테이블)이라는 자료구조에 각 프로세스의 정보를 저장하며, 프로세스의 구별을 위해 PID를 할당한다. pCB에 포함되는 프로세스 정보는 다음과 같다. 
 - PID	: 프로세스 ID
 - PPID	: 부모 프로세스의 PID
 - UID와 GID	: 실제 소유자 그룹 ID
 - EUID와 EGID	: 유효 소유자 그룹 ID
 - 프로세스의 현재 상태: 실행 / 준비 / 보류 등의 상태 표시와 CPU 사용 시간, 보류 시간 등의 기록
 - 프로세서의 우선순위: CPU 스케줄링에 사용는 우선순위 정보
 - 프로세스가 사용 중인 자원에 관한 정보: 프로세스에 할당된 메모리 주소, 입출력 장치, 파일에 관한 정보
 - 모든 대기 중인 시그널의 목록: 여러 종류의 시그널에 대해 어떻게 반응할지 대한 정보
 - 문맥 교환 정보: 프로세스가 중단되었다가 재시작될 때 필요한 CPU 레지스터의 내용.

02.
데몬 프로세스는 프린터의 사용, 로그 메시지의처리 또는 여러 시스템 서비스,나 네트워크 서비스를 제공하는 백그라운드 프로세스로 서버 기능을 하는 프로그램을 말한다. t버시ㅡ 요청을 기다렸다가 요청이 발생면 리해 주기 위해 시스템이 운영되는 동안 항상 실행 중에 있다. 프로그램의 뒤에 데몬을 의미하는 d가 붙는데, 예를 들어 httpd(웹 서버 데몬) 또는 sshd(원격 셸 데몬)과 같은 프로그램을 말한다.

1. 프로세서의 생성

00.
프로세스가 다른 프로세스를 생성하는 방법으로는 fork()와 exec() 쓰템 호출이 있다. 사용자 프로세스가 직접 할 수 없는 일을 수행하기 위해 커널에 서비스를 요청하는 것을 '시스템 호출'이라고 한다. 파일을 읽고 쓰는 일은 시스템 호출에 의해 수행된다.

01.
셸에서 명령을 수행하려면 새로운 프로세스가 만들어져 수행되어야 한다. 이때는 fork()와 exec() 시스템 호출이 필요하다.
fork()는 부포 프로세스가 신의 복사본 형태로 자식 프로세스를 만든다. fork()를 수행하면 PID와 PPID만 다르고 거의 동일한 두 개의 프로세스가 생긴다.
exec()는 새로운 프로세스를 만드는 대신에 기존 프로세스 새로운 프로세스로 대체하는 것으로, 원래 프로세스의 메모리 공간을 새로운 프로세스의 실행 코드로 덮어쓴다. 

예를 들어, ls 명령을 실행하 1) fork()에 의해 복사본 자식 프로세스가 새롭게 만들어지, exec(ls)  의해 ls 명령을 수행하는 로세스로 바뀌는 것이다. 간단히 셸의 자식 프로세스가 만들어진 후 여기서 ls 명령을 수행하고, 상탯값을 리턴하면서 자 프로세스가 종료된다는 것이다.   

2. 포어그라운드와 백그라운드 프로세스

00. 
보통 셸에서 명령을 실행하면 해당 프로세스튼 포어그라운드(foreground) 모드로 수행된다. 하나의 터미널에서는 포어그라운드 프로세스가 끝나기 전에는 다른 명령을 수행할 수 없다. 포어그라운드로 실행되는 프로세스는 키모드 입력을 받을 수 있고, 화면에 출력할 수 있다. 즉, 포어그라운 프로세스는 터미널에 대한 제어권을 가진다. 

01.
입력을 요구하지 않고 장시간 실행되어야 하는 경우 백그라운드(background) 프로세스로 실행시키는 것이 좋다. 백그라운드 프로세스는 보이지 않는 곳에서 숨어서 동작하는 프로그램이다. 백그라운드로 실행시키려면 셸 명령의 끝에 &를 추가하여 실행시킨다. 백그라운드 프로세스를 실행시키면 셸은 즉시 명령대기 상태가 되어 다음 명령을 계속 수행할 수 있다.

  - & 		: 실행명령어 뒤에 붙여 background로 실행시키는 옵션
  - Ctrl + C	: foreground process를 종료하는 명령어
  - Ctrl + Z	: 포어그라운드로 실행중인 프로세스를 백그라운드 프로스로 바꾸고 실행을 멈추게(stop) 핟다.
  - jobs	: 백그라운드에셔 실행 중이거나 멈춤 상태인 작업 록을 보여 준다.
  - bg 1	: 백그라운드에서 멈춤 상태인 1번 작업을 백그라운드에서 활성화 시킨다.
  - fg 1	: 1번 작업을 포어그라운드로 불러낸다.

3. 특수 권한

00. 
프로그램에 SetUID가 설정되어 있으면 누가 실행하더라도 해당 파일의 소유자가 실행한 것으로 간주된다. 이 경우 소유자의 실행권한 x가 아니라 s로 표시된다. SetGID는 그룹의 실행권이 s로 설정된 경우이다. 실행자의 그룹 권한이 아니라 소유자의 그룹 권한으로 실행된다. 주로 디렉터리에 설정된다.

01.
기타 사용자의 실행권한에 t가 표시되면 해당 파일의 소유자만 삭제 가능하다. 이를 StrickyBit 설정 이라고 한다. 주로 공유 디렉터리에 설정된다. 즉 누구나 파일을 생성(읽고 쓰기)할 수 있지만 삭제는 파일의 소유자만 가능하다. 

02.
SetUID, SetGID, StrickyBit 설정은 chmod 명령을 사용한다. '8진수 모드' 방법의 세 자리 8진수 앞에 4(SetUID), 2(SetGID), 1(StrickyBit)을 붙이거나 기호 모드에서 x 대신에 s(SetUID, SetGID)나 t(StrickyBit)를 사용하면 된다. 

	chmod 4755 /bin/ls  또는  chmod u+s /bin/ls를 수행하면 된다.

	chomd 0755 /bin/ls  또는  chmod u-s /bin/ls로 설정을 해제할 수 있다. 


9.2 프로세스의 상태

  1. 프로세스의 상태 변화

  1) (생성) 사용자가 작업을 요청하면 프로세스가 커널에 등록되고 생성상태가 된다.
  2) (준비) 생성 상태에서 하드디스크로부터 메모리로 프로세스가 로드되면 프로세스는 준비 상태가 된다. 
     (지연준비) 충분한 메모리 공간이 없다면 지연준비 상태로 들어간다.
  3) (실행) 준비 상태에서 CPU 스케줄러가 특정 프로세스에 CPU를 할당하면 해당 프로세스가 실행 상태가 되는데, 
            이 과정을 dispatch라 한다. 
	    이 상태에서 CPU는 프로세스가 가진 명령어를 실행한다.
  4) (준비 상태로 복귀) 실행 상태에 있는 프로세스가 주어진 시간 동안 작업을 끝내지 못하거나(time out이 되거나), 
			우선순위가 높은 프로세스가 등장하면 CPU 스케줄러에에 의해 다른 프로세스가 CPU를 선점한다. 
			이때 원 프로세스는 다시 준비 상태로 들어간다.
  5) (보류, 대기) 실행 상태의 프로세스가 사용자 일력이나 출력장치의 사용을 기다리거나 하면 
		  보류 상태(또는 대기 상태)로 들어간다. 보류 상태란 입출력의 완료나 어떤 사건을 기다리는 상태이다.
  6) (웨이크업, wakeup) 보류 상태에서 입출력 처리 작업이 종료되면 준비 상태로 들어가서 CPU가 할당되기를 기다리는데, 
			이 과정을 웨이크업이라고 한다.
  7) (지연준비, 지연 보류) 준비 또는 보류 상태에서 가지고 있던 메모리를 내놓고 지연준비 또는 지연보류상태로 
			   전이될 수 있다. 실행 중인 프로세스도 CPU와 메모리를 함께 내놓고 지연준비상태로 전이될 수 있다.
  8) (종료) 실행 상태의 프로세스가 실행을 마무리하면 프로세스는 종료 상태 되고, 가지고 있던 모든 자원을 반환한다.

### Ctrl+Z, fg, bg는 “터미널이 제어 중인 프로세스(job)”만 다룰 수 있고, GUI에서 실행된 프로세스는 터미널의 제어를 받지 않기 때문입니다. Ctrl+Z → bg/fg는 전부 “쉘 ↔ 터미널 ↔ 자식 프로세스” 사이의 제어 신호 교환으로 이뤄집니다

  2. 프로세스 상태 보기: ps 
   
  ### Linux 명령 option 3 styles
   - GNU style	: 이중대시(--)로 시작하는 긴 스타일의 옵션
   - Unix style : 짧은대시(-)로 시작하며, 영문 한글자를 사용하고, 해당 옵션의 나열로 여러 옵션을 동시에 지정할 수 있다.
   - BSD style	: 대시를 사용하지 않는다.

00. 
ps 명령에서 자주 사용되는 옵션은 -ef와 aux 이다. 
둘 다 모든 사용자의 모든 프로세스(-e 또는 ax)에 관해 많은 정보(-f 또는 w)를 보여 준다.

	ps -ef --forest      ps aux

01.
출력되는 양이 많을 때는 파이프(|)를 사용하여 grep 명령과 연결시키거나 more 명령으로 연결시키는 방법을 사용한다. 

  ### ps 명령의 출력 결과에서 항목 헤더의 의미
  - tty	: 프로세스와 연결된 터미널, 연결이 없다면 ?가 표시됨
  - STAT	: 프로세스의 상태 코드 
		  	R: 실행 중 또는 실행 가능한 상태,	
			S: 인터럽트될 수 있는 수면상태로 대개 이벤트의 종료를 기다리는 상태
			D: 인터럽트가 불가능한 수면상태로 대개 디스크 입출력 중인 상태
			T: 시그널에 의해 멈춰진 지연상태
			X: 죽은 상태
			Z: 좀비 프로세스, 작업이 종료되었으나 부모 프로세스에 의해 회수되지 않은 프로세스
			<: 높은 우선순위
			N: 낮은 우선순위로 다른 프로세스에 nice함.
			L: 메모리 안에서 페이지가 잠긴 상태(실시간 처리 또는 IO에 의해서 발생)
			s: 세션 리더
			l: 멀티스레드 상태
			+: 포어그라운드 프로세스
  - TIME	: 누적CPU 사용 시간
  - USER	: 프로세스 유효 소유자의 ID
  - RSS	: 프로세스가 점유한 메모리의 크기
  - %CPU	: 프로세스 실행 중 해당 프로세스의 CPU 점유율
  - %MEM	: 전체 메모리 중 해당 프로세스의 메모리 점유율
  - WCHAN	: 프로세스가 수면상태일 때 커널 함수의 이름. 실행 중일 때는 '-', 다중스레드일 때는 '*'로 표시됨.

9.3 프로세스 관리

00.
ps 명령은 한순간의 프로세스 상태를 보여주는 스냅샷이라고 할 수 있는데, 프로세스의 수행 상황을 실시간으로 모니터할 수 있는 명령도 필요하다.

  1. 프로세스 모티너링과 관리 명령: top

00. 
현재 실행 중인 프로세스의 상태와 시스템 자원의 동적 운영 상황을 실시간으로 확인하려면 top 명령을 사용한다. 
프로세스의 상태뿐만 아니라 CPU와 메모리 사용율, 시스템의 부하 등을 기본적으로 3초 간격로 갱신하여 화면상에 보여준다.
또한 프로세스의 상태 관리를 위 대화식 인터페이스를 제공한다.    
 
01.(top 명령의 출력 결과에서 항목의 의미
  - PR	: 프로세스의 우선순위
  - VIRT	: 프로세스가 사용한 가상 메모리의 총량(kb)
  - RES		: 프로세스가 사용 중인 메인 메모리의 양(Kb)
  - SHR		: 프로세스가 사용한 공유 메모리의 양(kb)
  - S	: 프로세스 상태를 단히 표시한 것으로 D/R/S/T/Z 중 하 

  2. 시그널 보내기: kill

00.
kill 명령은 지정한 프로세스에 다양한 시그널(프로세스 중단 증)을 보내는 기능을 수행한다.

01.
관리자 관점에서 가장 자주 사용하는 시그널은 KILL(9)과 TERM(15)이다. kill 명령을 사용하여 시그널을 보내려면 시그널을 받는 프로세스의 PID가 필요하며, 시그널이 생략되면 TERM(15)로 간주된다.
  - KILL(9) 시그널은 프로세스 강제로 즉시 종료시키는 시그널이다. 
  - TERM(15) 시그널은 Kill 명령의 기본 시그널로 프로세스에 정리 작업(clean-up) 후 스스로 종료할 것을 요청하는 것이다.  

02. kill 명령의 사용법은 다음과 같다.

	kill [-s signal] pids		kill [-signal] pids

03. 리눅스에서 yㅇ되는 시그널
  - HUP		: Hang-up의 의미로 부모 프로세스나 터미널이 종료될 때 연결된 프로세스에 보내지는 시그널이다.
  - INT		: Interrupt의 의미로 터미널에서 Ctrl+C를 누르는 것과 같다. 프로그램 종료시킨다.
  - KILL	: 프로세스를 강제 종료시킨다. 프로세스가 종료 전에 스스로를 정리할 기회를 주는 것이다.
  - TERM	: Terminate 의미로 kill 명령의 기본 시그널이다. 정상적인 종료 방법으로 프로그램을 끝낼 기회를 제공한다.
  - CONT	: Continue의의미로 STOP 시그널로 중단된 프로세르를 재개한다.
  - STOP	: Stop의 믜미로 프로세스를 잠시 중단시킨다.
  - TSTP	: Terminal Stop의 의미로 터미널에서 Ctrl+Z를 누르는 것과 같다. STOP과 달리 무시당할 수 있다.

04.
특정 프로세스에 한꺼번에 시그널을 보려면 killall 명령을 사용한다.

	killall [options] [-s signal] [-u user] names


  3. 우선순위의 조정: nice와 renice

00.
nice 명령은 프로그램을 실행할 때 'nice 우선순위 값(또는 NI값)을 설정하여 프로그램을 실행하는 명령이다. NI값이 가장 높은 우선순위는 -20이며, 가장 낮은 우선순위 +19이다. 우선순위가 높으면 CPU를 점유할 확률이 높다고 할 수 있다. 
명령을 실행할 때 기본적 NI값은 0으로 주어지며, 일반 사용자는 NI값을 0 이상으로만 지정할 수 있다. 즉 우선순위를 낮추어 남에게 nice하게 하는 것만 가능하다.

01.
실행 중인 프로세스의 NI값을 바꾸는 명령은 renice이다.

  4. nohup 명령

00.
사용자가 로그아웃하거나 exit 명령으로 터미널 창을 끝내면 백그라운드 프로세스에도 HUP(Hang-up;종료하라) 시그널이 보내진다. 터미널이 종료되더라도 백그라운드 프로세스가 HUP 시그널의 수신과 관계 없이 스스로 종료할 때까지 계속 수행하게 하려면, 백그라운드 명령을 수행시킬 때 nohup 명령을 사용한다.

예를 들어 	nohup find -size +100k > log.txt &	이 명령은

터미널이 종료되더라도 계속 작업을 수행하여 크기가 100K보다 큰 파일을 찾아 log.txt 파일에 기록한다. 만약 표준출력이 종료된 터미이라면 표준출력과 표에러는 nohup.out 파일에 기록된다.


  5. cron 서비스

00.
지정된 시간에 맞추어 주기적으로 수행되는 계획된 작업을 수행할 때 cron 서비스가 사용된다. cron 서비스는 시스템 부팅 후부터 계속 수행되고 있는 crond라는 데몬 프로그램을 제공한다. 이 crond 데몬은 1분 간격 시스템 또는 일반 사자 'crontab 파일'의 내용을 검사하여 정해 시간에 작업을 수행한다. 'crontab파일'의 내용이란 원하는 시간에 주기적으로 수행되어야 하는 'cron 작업'의 리스트를 뜻한다. 시스템의 crontab 파일은 /etc/crontab 파일과 /etc/cron.d/ 디렉터리에 존재하는 파일을 말한다.

01.  crontab 파일에서 'cron 작업'을 설정하기 위한 항목은
   - 분(0~59 사이), 
   - 시(0~23 사이), 
   - 날짜( 1~31 사이), 
   - 달(1~12 또는 jan, feb 등), 
   - 요일(0~7 또는 sun, mon 등으로 결정한다. 0은 일요일이다), 
   - 사용자 이름, 
   - 실행할 명령

02.
시간을 표시하기 위한 필ㄷ르에0는 매번을 의미하는 애스터리스크(*), 범위를 표시하기 한 대시(-)와 콤마(,) 그리고 지정된 범위에서 기를 표기하기 위해 슬래시(/)를 사용할 수 있다.

예를 들어 	01 **** root run-parts /etc/corn.hourly		는

		매요일 매달 매일 매시 1분에 /etc/cron.hourly 디렉터리 아래의 파일을 싱행하는 것을 의미한다. 

또 다른 예로	0 */6 * * 1-5 /bin.mail -s "Hi" jjpark@localhost	는
		
		월요일부터 금요일까지 0시 정각을 포함하여 6시간 마다 메일을 보내라는 명령이다.

03.
일반 사용자도 자신만의 cron 작업을 자신의 crontab 파일에 등록할 수 있는데, 이때 반드시 crontab 명령을 사용해야 한다.

04. crontab 명령에서 사용되는 옵션

   -l	: crontab 파일에 등록된 작업 리스트를 출력한다.
   -e	: crontab 파일을 편집하여 등록하거나 수정한다.
   -r	: crontab 파일을 삭제한다.
   -u user	: 지정된 사용자의 crontab 파일을 사용한다. 

04. at 명령
cron 서비스를 사용하지 않고 특정 시간에 일회성으로 작업을 예약하려면 at 명령을 사용한다. at 명령은 표준입력 장치나 지정된 파일에서 작업을 읽어 들인다. 

		$ at 00:10 08. 04. 25
		at> date >> list.txt
		at> <EOT>
		job 1 at Sat Apr 8 00:10:00 2025

### 리눅스 서버가 오랫동안 중단되었거난 다시 시작되면 그동안 못했던 cron 작업을 수행하는라 과부하가 걸릴 수 있다. 이 경우에 anacron을 사용한다. anacron의 설정 파일은 /etc/anacrontab이다. 이것은 설정 파일에 기록된 작업이 지난 며칠 동안 실행된 적이 없는 경우 몇 분의 여유를 두고 작업을 실행한다.

	 
